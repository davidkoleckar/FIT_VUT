#include "Scene.h"

/**
 * Load scene from obj file generated by Blender
 */
void Scene::loadObjFile(string filename) {
    cout << "Loading: " << filename << endl;
    m_triangles.clear();

    ifstream fs(filename);

    string line;
    char c;
    string name;
    std::smatch m;
    // Vertex position
    glm::vec3 position;
    // Indicies
    unsigned int indicies[3];
    // Properties of triangles
    glm::vec3 currentColor = glm::vec3(0.0f);
    glm::vec3 currentEmission = glm::vec3(0.0f);
    glm::vec3 currentReflection = glm::vec3(0.0f);
    glm::vec3 currentRadiosity = glm::vec3(1.0f);

    while(std::getline(fs, line)) {
        std::istringstream iss(line);
        iss >> c;

        switch(c) {
            // Set properties according to object
            case 'o': 
                iss >> name;
                // wall - RED
                if (regex_search(line, m, std::regex("\\w*(front-wall)\\w*") )) {
                    currentColor = 0.7 * glm::vec3(1.0f, 0.25f, 0.0f);
                    currentEmission = glm::vec3(0.0f, 0.0f, 0.0f);
                    currentReflection = glm::vec3(1.0f, 0.25f, 0.0f);
                    currentRadiosity = glm::vec3(0.0f, 0.0f, 0.0f);
                }
                // wall - WHITE
                else if (regex_search(line, m, std::regex("\\w*(left-wall)\\w*") )) {
                    currentColor = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentEmission = glm::vec3(0.0f, 0.0f, 0.0f);
                    currentReflection = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentRadiosity = glm::vec3(0.0f, 0.0f, 0.0f);
                }
                // WALL - GREEN
                else if (regex_search(line, m, std::regex("\\w*(wall)\\w*") )) {
                    currentColor = 0.7 * glm::vec3(0.0f, 1.0f, 0.25f);
                    currentEmission = glm::vec3(0.0f, 0.0f, 0.0f);
                    currentReflection =  glm::vec3(0.0f, 1.0f, 0.25f);
                    currentRadiosity = glm::vec3(0.0f, 0.0f, 0.0f);
                }
                // cube
                else if (regex_search(line, m, std::regex("\\w*([C|c]ube)\\w*") )) {
                    currentColor = 0.2 * glm::vec3(1.0f, 1.0f, 1.0f);
                    currentEmission = glm::vec3(0.0f, 0.0f, 0.0f);
                    currentReflection =  0.2 * glm::vec3(1.0f, 1.0f, 1.0f);
                    currentRadiosity = glm::vec3(0.0f, 0.0f, 0.0f);
                }
                // window
                else if (regex_search(line, m, std::regex("\\w*(window)\\w*") )) {
                    currentColor = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentEmission = glm::vec3(.0f, 0.0f, 0.0f);
                    currentReflection = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentRadiosity = glm::vec3(0.0f, 0.0f, 0.0f);
                }
                // floor
                else if (regex_search(line, m, std::regex("\\w*(floor)\\w*") )) {
                    currentColor = 0.9 * glm::vec3(1.0f, 1.0f, 1.0f);
                    currentEmission = glm::vec3(0.0f, 0.0f, 0.0f);
                    currentReflection = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentRadiosity = glm::vec3(0.0f, 0.0f, 0.0f);
                }
                // light source
                else if (regex_search(line, m, std::regex("\\w*(light)\\w*") )) {
                    currentColor = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentEmission = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentReflection = glm::vec3(1.0f, 1.0f, 1.0f);
                    currentRadiosity = glm::vec3(1.0f, 1.0f, 1.0f);
                }
                break;
            // Vertex
            case 'v': {
                iss >> position.x;
                iss >> position.y;
                iss >> position.z;
                Vertex vertex = {position, currentReflection, currentRadiosity, 0};
                m_vertices.push_back(vertex);
                break;
            }
            // Indicies
            case 'f': {
                iss >> indicies[0];
                iss >> indicies[1];
                iss >> indicies[2];
                m_indices.push_back(indicies[0] - 1);
                m_indices.push_back(indicies[1] - 1);
                m_indices.push_back(indicies[2] - 1);
                // Create triangle
                Triangle triangle(indicies[0] - 1, indicies[1] - 1, indicies[2] - 1);
                triangle.setEmission(currentEmission);
                triangle.setReflection(currentReflection);
                triangle.setRadiosity(currentRadiosity);
                triangle.setColor(currentColor);
                // Save triangle index
                triangle.setIndex(m_triangles.size());
                m_triangles.push_back(triangle);
                break;
            }
            // Skip line
            default:
                break;
        }
    }

    fs.close();
    cout << "Done" << endl;
}

/**
 * Get size of vertices and colors buffer
 */
unsigned int Scene::getVerticesSize() {
    return m_vertices.size() * sizeof(Vertex);
}

/**
 * Get buffer of all vertices and their colors
 */
void* Scene::getVertices() {
    return (void*) &m_vertices.front();
}

/**
 * Get vector of Points in scene
 */
vector<Vertex>& Scene::getVerticesVec() {
    return m_vertices;
}

/**
 * Get size of indices buffer
 */
unsigned short Scene::getIndicesSize() {
    return m_triangles.size() * 3 * sizeof(unsigned short);
}

/**
 * Get number of all indices
 */
unsigned short Scene::getIndicesCount() {
    return m_triangles.size() * 3;
}

/**
 * Get vector of all indices
 */
void* Scene::getIndices() {
    return &(m_indices.front());
}


vector<ushort> Scene::getIndicesVec() {
    return m_indices;
}

/**
 * Get all triangles
 */
vector<Triangle>& Scene::getTriangles() {
    return m_triangles;
}

/**
 * Get patch with max unshot emission
 */
Triangle& Scene::getMaxPatch() {
    return *std::max_element(m_triangles.begin(), m_triangles.end());
}

/**
 * Get triangle at specified index
 */
Triangle& Scene::getTriangle(unsigned int index) {
    return m_triangles.at(index);
}

/**
 * Reset form factors to zero for each triangle
 */
void Scene::resetFormFactors() {
    for (Triangle t : m_triangles) {
        t.setFormFactor(0.0f, 0);
    }
}

/**
 * Reset color in all vertices to 0
 */
void Scene::resetVerticesColor() {
    for (Vertex& vertex : m_vertices) {
        vertex.color = glm::vec3(0.0f);
        vertex.radiosity = glm::vec3(0.0f);
    }
}
